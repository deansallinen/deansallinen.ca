<!DOCTYPE html><html><head><meta charset="utf-8"/><meta http-equiv="x-ua-compatible" content="ie=edge"/><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"/><link rel="preload" href="/component---src-layouts-index-js-c7b949255d617ff6f539.js" as="script"/><link rel="preload" href="/component---src-templates-blog-template-js-580e315ea23c55a6f93d.js" as="script"/><link rel="preload" href="/path---projects-mailroom-0703996f543ef3573f7c.js" as="script"/><link rel="preload" href="/app-7f8c8c2352d9d219a48d.js" as="script"/><link rel="preload" href="/commons-afb5782224ac01f1fa03.js" as="script"/><title data-react-helmet="true">Dean Sallinen</title><meta data-react-helmet="true" name="description" content="Sample"/><meta data-react-helmet="true" name="keywords" content="sample, something"/><style id="gatsby-inlined-css">html{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary{display:block}audio,canvas,progress,video{display:inline-block}audio:not([controls]){display:none;height:0}progress{vertical-align:baseline}[hidden],template{display:none}a{background-color:transparent;-webkit-text-decoration-skip:objects}a:active,a:hover{outline-width:0}abbr[title]{border-bottom:none;text-decoration:underline;text-decoration:underline dotted}b,strong{font-weight:inherit;font-weight:bolder}dfn{font-style:italic}h1{font-size:2em;margin:.67em 0}mark{background-color:#ff0;color:#000}small{font-size:80%}sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}img{border-style:none}svg:not(:root){overflow:hidden}code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}figure{margin:1em 40px}hr{box-sizing:content-box;height:0;overflow:visible}button,input,optgroup,select,textarea{font:inherit;margin:0}optgroup{font-weight:700}button,input{overflow:visible}button,select{text-transform:none}[type=reset],[type=submit],button,html [type=button]{-webkit-appearance:button}[type=button]::-moz-focus-inner,[type=reset]::-moz-focus-inner,[type=submit]::-moz-focus-inner,button::-moz-focus-inner{border-style:none;padding:0}[type=button]:-moz-focusring,[type=reset]:-moz-focusring,[type=submit]:-moz-focusring,button:-moz-focusring{outline:1px dotted ButtonText}fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}legend{box-sizing:border-box;color:inherit;display:table;max-width:100%;padding:0;white-space:normal}textarea{overflow:auto}[type=checkbox],[type=radio]{box-sizing:border-box;padding:0}[type=number]::-webkit-inner-spin-button,[type=number]::-webkit-outer-spin-button{height:auto}[type=search]{-webkit-appearance:textfield;outline-offset:-2px}[type=search]::-webkit-search-cancel-button,[type=search]::-webkit-search-decoration{-webkit-appearance:none}::-webkit-input-placeholder{color:inherit;opacity:.54}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{font:112.5%/1.45em georgia,serif;box-sizing:border-box;overflow-y:scroll}*,:after,:before{box-sizing:inherit}body{color:#333;font-family:georgia,serif;font-weight:400;word-wrap:break-word;-webkit-font-kerning:normal;font-kerning:normal;-ms-font-feature-settings:"kern","liga","clig","calt";-webkit-font-feature-settings:"kern","liga","clig","calt";font-feature-settings:"kern","liga","clig","calt","kern"}img{max-width:100%;margin:0 0 1.45rem;padding:0}h1{font-size:2.25rem}h1,h2{margin:0 0 1.45rem;padding:0;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h2{font-size:1.62671rem}h3{font-size:1.38316rem}h3,h4{margin:0 0 1.45rem;padding:0;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h4{font-size:1rem}h5{font-size:.85028rem}h5,h6{margin:0 0 1.45rem;padding:0;color:inherit;font-family:-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Oxygen,Ubuntu,Cantarell,Fira Sans,Droid Sans,Helvetica Neue,sans-serif;font-weight:700;text-rendering:optimizeLegibility;line-height:1.1}h6{font-size:.78405rem}hgroup{margin:0 0 1.45rem;padding:0}ol,ul{margin:0 0 1.45rem 1.45rem;padding:0;list-style-position:outside;list-style-image:none}dd,dl,figure,p{margin:0 0 1.45rem;padding:0}pre{padding:0;font-size:.85rem;line-height:1.42;background:rgba(0,0,0,.04);border-radius:3px;overflow:auto;word-wrap:normal;padding:1.45rem}pre,table{margin:0 0 1.45rem}table{padding:0;font-size:1rem;line-height:1.45rem;border-collapse:collapse;width:100%}fieldset{margin:0 0 1.45rem;padding:0}blockquote{margin:0 1.45rem 1.45rem;padding:0}form,iframe,noscript{margin:0 0 1.45rem;padding:0}hr{margin:0 0 calc(1.45rem - 1px);padding:0;background:rgba(0,0,0,.2);border:none;height:1px}address{margin:0 0 1.45rem;padding:0}b,dt,strong,th{font-weight:700}li{margin-bottom:.725rem}ol li,ul li{padding-left:0}li>ol,li>ul{margin-left:1.45rem;margin-bottom:.725rem;margin-top:.725rem}blockquote :last-child,li :last-child,p :last-child{margin-bottom:0}li>p{margin-bottom:.725rem}code,kbd,samp{font-size:.85rem;line-height:1.45rem}abbr,abbr[title],acronym{border-bottom:1px dotted rgba(0,0,0,.5);cursor:help}abbr[title]{text-decoration:none}td,th,thead{text-align:left}td,th{border-bottom:1px solid rgba(0,0,0,.12);font-feature-settings:"tnum";-moz-font-feature-settings:"tnum";-ms-font-feature-settings:"tnum";-webkit-font-feature-settings:"tnum";padding:.725rem .96667rem calc(.725rem - 1px)}td:first-child,th:first-child{padding-left:0}td:last-child,th:last-child{padding-right:0}code,tt{background-color:rgba(0,0,0,.04);border-radius:3px;font-family:SFMono-Regular,Consolas,Roboto Mono,Droid Sans Mono,Liberation Mono,Menlo,Courier,monospace;padding:0;padding-top:.2em;padding-bottom:.2em}pre code{background:none;line-height:1.42}code:after,code:before,tt:after,tt:before{letter-spacing:-.2em;content:" "}pre code:after,pre code:before,pre tt:after,pre tt:before{content:""}@media only screen and (max-width:480px){html{font-size:100%}}</style></head><body><div id="___gatsby"><div data-reactroot="" data-reactid="1" data-react-checksum="2027152130"><!-- react-empty: 2 --><div style="background:maroon;margin-bottom:1.45rem;" data-reactid="3"><div style="margin:0 auto;max-width:960px;padding:1.45rem 1.0875rem;" data-reactid="4"><h3 style="margin:0;display:inline;" data-reactid="5"><a style="color:#eee;text-decoration:none;" href="/" data-reactid="6">Dean Sallinen</a></h3><ul style="list-style:none;float:right;font-family:sans-serif;" data-reactid="7"><li style="display:inline-block;margin-right:1rem;" data-reactid="8"><a style="text-decoration:none;color:#eee;" href="/about" data-reactid="9">About</a></li></ul></div></div><div style="margin:0 auto;max-width:960px;padding:0px 1.0875rem 1.45rem;padding-top:0;" data-reactid="10"><div class="blog-post-container" data-reactid="11"><div class="blog-post" data-reactid="12"><h1 data-reactid="13">Interoffice Mailroom Webapp</h1><div class="blog-post-content" data-reactid="14"><h1>Interoffice Mailroom Webapp</h1>
<h2>Overview</h2>
<p>This app intends to solve a client's problem with interoffice mail. Employees will fill out address information for their letters and parcels and our app will generate a QR code which they print and attach to their mail. When the mailroom receives this letter/parcel they can then scan the QR code which will query the database for the relevant address information. The mailroom can then weigh the package, decide on the correct carrier and shipping methodology, generate the shipping label and ship the package.</p>
<h2>Setup</h2>
<p>We'll start by creating a new directory on the command line with <code>$ mkdir mailroom</code> and run <code>$ npm install express-generator -g</code> to install the tool that will allow us to skeleton out our app quickly.</p>
<p>Run <code>$ express --no-view --git --force</code> to skeleton an app with no templating engine (because we plan on using React) as well as an empty .gitignore file and we add the force flag because the directory currently contains this markdown file.</p>
<p>Now we can begin installing packages for our app. First run <code>$ npm install</code> to install the packages required by express. Now would also be a good time to initialize a git repository.</p>
<p>Run <code>$ git init</code> and <code>$ git add -A</code> to add the beginnings of our app to the git repository, now make the first commit with <code>$ git commit -m "initialize repo"</code>. Now our app is under version control and if we make a mistake adding new features, we can easily roll back to a time when our app worked!</p>
<p>Okay lets test our express installation. Run <code>$ npm start</code> and open up a browser to <a href="http://localhost:3000">http://localhost:3000</a> where you should see the following image. This means the installation was successful.</p>
<p><img src="/screenshots/000.png" alt="screenshot of express default page"></p>
<h2>Database</h2>
<p>Let's set up the database. First, stop the server with <code>CTRL-C</code>. Since we will be using Sqlite for our database we can run <code>$ npm install sqlite bluebird --save</code>. I've chosen to use sqlite instead of sqlite3 as this lets us use promises instead of callbacks to access the database. Also installed bluebird as this seems to be the consensus over ES6 promises. Not sure I like that. But lets get something working and come back to that.</p>
<p>Create a folder for migrations, which will be useful going forward when we want to modify the database schema <code>$ mkdir migrations &#x26;&#x26; cd migrations</code>. Lets create our first migration <code>$ touch 001-init.sql</code> and write some SQL.</p>
<pre><code class="language-sql">-- Up
CREATE TABLE parcels
(
    id INTEGER PRIMARY KEY,
    user_id TEXT,
    file_id TEXT,
    shipment_type TEXT,
    shipment_destination TEXT,
    shipment_speed TEXT,
    attn_name TEXT,
    attn_phone TEXT,
    attn_organization TEXT,
    street_address TEXT,
    city TEXT,
    state_or_province TEXT,
    country TEXT,
    postal_code TEXT,
    us_value_of_goods TEXT,
    us_content_declaration TEXT,
    barcode TEXT,
    carrier_tracking_number TEXT,
    shipment_weight INT,
    shipment_length INT,
    shipment_width INT,
    shipment_height INT,
    shipping_method TEXT,
    shipment_status TEXT,
    creation_date TEXT,
    received_date TEXT
);

INSERT INTO parcels
    (user_id, street_address, attn_name,
    attn_organization, city, state_or_province, country, postal_code, barcode)
VALUES
    ("1A", "123 Example Street", "Spiderman", "The Avengers", "New York City", "New York", "US", "12345", "f34c6658-818b-11e8-adc0-fa7ae01bbebc");

-- Down
DROP TABLE parcels;
</code></pre>
<p>Now to start we'll add our database connection in <code>app.js</code> for quicker prototyping and refactor it later:</p>
<pre><code class="language-javascript">const Promise = require('bluebird')
const sqlite = require('sqlite')
const dbPromise = Promise.resolve()
  .then(() => sqlite.open('./mailroom.sqlite', { Promise }))
  .then(db => db.migrate({ force: 'last' }))
</code></pre>
<p>Which will create a database file in our root directory (if it doesn't already exist), add some test data, open a connection, and use the latest migration to ensure our database is using the newest schema during development.</p>
<h2>Writing Tests</h2>
<p>For running tests we will install Mocha, Chai, and ChaiHTTP.</p>
<p>Run <code>$ npm install mocha -g &#x26;&#x26; npm install mocha chai chai-http --save-dev</code> then <code>$ mkdir test</code></p>
<h2>Routing</h2>
<p>Lets start by creating a test file with <code>$ touch test/routes.spec.js</code> where we will add the tests for our API routes. First include the above libraries and tell Chai to use the HTTP module.</p>
<pre><code class="language-javascript">const chai = require('chai')
const should = chai.should()
const chaiHttp = require('chai-http')
const server = require('../app')

chai.use(chaiHTTP)
</code></pre>
<h3>GET</h3>
<p>Now we can describe our first test. Let's test that when we hit the <code>/api/v1/parcels</code> URL we receive an array of all parcels in the database.</p>
<pre><code class="language-javascript">describe('API Routes', function() {
  describe('GET /api/v1/parcels', function() {
    it('should return all parcels', function(done) {
      chai
        .request(server)
        .get('/api/v1/parcels')
        .end(function(err, res) {
          res.should.have.status(200)
          res.should.be.json
          res.body.should.be.a('array')
          done()
        })
    })
  })
})
</code></pre>
<p>Now if we run <code>$ mocha</code> on the command line to start our test we see the following error:</p>
<pre><code>deans-Mac-Pro:mailroom dean$ mocha


  API Routes
    GET /api/v1/parcels
GET /api/v1/parcels 200 5.857 ms - 11
      1) should return all parcels


  0 passing (58ms)
  1 failing

  1) API Routes
       GET /api/v1/parcels
         should return all parcels:
     Uncaught AssertionError: expected 'text/html; charset=utf-8' to include 'application/json'
      at /Users/dean/Documents/projects/mailroom/test/routes.spec.js:16:25
      at Test.Request.callback (node_modules/superagent/lib/node/index.js:716:12)
      at IncomingMessage.parser (node_modules/superagent/lib/node/index.js:916:18)
      at endReadableNT (_stream_readable.js:1062:12)
      at process._tickCallback (internal/process/next_tick.js:152:19)
</code></pre>
<p>It's saying that it isn't receiving json back from the server, so let's correct that by first opening <code>app.js</code> and adding</p>
<pre><code class="language-javascript">// Routes
app.get('/api/v1/parcels', async (req, res, next) => {
  try {
    const db = await dbPromise
    const parcels = await db.all('SELECT * FROM parcels')
    res.send(parcels)
  } catch (err) {
    next(err)
  }
})
</code></pre>
<p>So now when our client hits the '/api/v1/parcels' route the server opens a connection to the database, selects all parcels from our parcels table, and sends the result back to the client.</p>
<h3>POST</h3>
<p>Before we write the code that lets us add a new parcel, we need some helpers. Lets run <code>$ npm install uuid -s</code> and in <code>app.js</code> add</p>
<pre><code class="language-javascript">const uuidv4 = require('uuid/v4')
</code></pre>
<p>Lets write another test, inside the same 'API Routes' function block just underneath the 'GET /api/v1/parcels' test, this time for posting a new parcel to the server:</p>
<pre><code class="language-javascript">describe('POST /api/v1/parcels', function() {
    it('should create one parcel', function(done) {
      chai
        .request(server)
        .post('/api/v1/parcels')
        .send({
          user_id: 'Dean',
          street_address: '1234 Main St',
          attn_name: 'test',
          attn_organization: 'test',
          city: 'test',
          state_or_province: 'test',
          country: 'test',
          postal_code: 'test',
          barcode: '0e2887fc-19c9-4bf5-a9fc-0c5f5a23a87c',
          shipment_status: 'test',
          creation_date: 'test',
        })
        .end(function(err, res) {
          res.should.have.status(200);
          done();
        });
    });
</code></pre>
<p>Notice how we don't have every field? When we are creating a new parcel, this is the data the user will enter. When the mailroom later updates the parcel with the shipping information and the package dimensions, they will update this record.</p>
<p>And again we go into <code>app.js</code> to add a route:</p>
<pre><code class="language-javascript">app.post('/api/v1/parcels', async (req, res, next) => {
  try {
    const payload = {
      $user_id: req.body.user_id,
      $street_address: req.body.street_address,
      $attn_name: req.body.attn_name,
      $recipient_first_name: req.body.recipient_first_name,
      $recipient_last_name: req.body.recipient_last_name,
      $attn_organization: req.body.attn_organization,
      $city: req.body.city,
      $state_or_province: req.body.state_or_province,
      $country: req.body.country,
      $postal_code: req.body.postal_code,
      $uuid: uuid,
      $parcel_status: req.body.parcel_status,
      $creation_date: new Date().toISOString(),
    }
    const uuid = uuidv4()
    const db = await dbPromise
    const parcels = await db.run(
      `INSERT INTO parcels (
            user_id,
            street_address,
            attn_name,
            attn_organization,
            city,
            state_or_province,
            country,
            postal_code,
            barcode,
            shipment_status,
            creation_date) 
        VALUES (       
            $user_id,
            $street_address,
            $attn_name,
            $attn_organization,
            $city,
            $state_or_province,
            $country,
            $postal_code,
            $barcode,
            $shipment_status,
            $creation_date)`,
      payload
    )
    res.send({
      message: 'Success!',
      barcode: uuid,
    })
  } catch (err) {
    next(err)
  }
})
</code></pre>
<p>Instead of sending an array of values as the payload we can send an object with key:value pairs. Make sure to include the <code>$</code> in front of the key otherwise sqlite won't recognize it as a placeholder! (multiple hours spent trying to figure out why this wasn't working...)</p>
<p>Here when a client hits the <code>/api/v1/parcels</code> route with a POST request and supplies address information that is saved in the database as a new record. Notice how we are using <code>uuidv4()</code> to generate a unique code for each record. We return the uuid as the response, the idea being we will use this to generate the barcode in the front-end. We also use <code>new Date().toISOString()</code> to add a timestamp of when that record was created.</p>
<p>If you're wondering (like I did) why it seems like the POST request is updating and not inserting new values each time the test is run, it's because we added <code>{ force: 'last' }</code> to re-run the latest migration every time we restart our server. So even though it looks like the barcode and creation_date are changing in place, it's really:</p>
<ol>
<li>Dropping the parcels table</li>
<li>Inserting the two sample rows in our 001-init.sql file</li>
<li>POSTing the new row with the new data</li>
</ol>
<h3>PUT</h3>
<p>When a package is received by the mailroom IRL they will scan the barcode and pull up the parcel in the database to add shipping information and package dimensions.</p>
<p>So before we can make updates to parcels, we need to be able to GET individual parcels by their barcode.</p>
<p>In <code>routes.spec.js</code> we can add a new test for the new route we are about to create:</p>
<pre><code class="language-javascript">describe('GET /api/v1/parcels/:barcode', function() {
  it('should return one parcel', function(done) {
    chai
      .request(server)
      .get('/api/v1/parcels/f34c6658-818b-11e8-adc0-fa7ae01bbebc')
      .end(function(err, res) {
        res.should.have.status(200)
        res.should.be.json
        res.body.should.be.a('object')
        done()
      })
  })
})
</code></pre>
<p>Here we are using a barcode from one of our sample rows in the 001-init.sql file as these are static and easy to reference.</p>
<p>Run the test with <code>$ mocha</code> and see that it fails with a 404. Now we need to write the route. In app.js under our other routes add:</p>
<pre><code class="language-javascript">app.get('/api/v1/parcels/:barcode', async (req, res, next) => {
  try {
    const db = await dbPromise
    const parcels = await db.get(
      'SELECT * FROM parcels WHERE barcode = ?',
      req.params.barcode
    )
    res.send(parcels)
  } catch (err) {
    next(err)
  }
})
</code></pre>
<p>Rerun the test and voila! 3 passing tests. You can even verify in the browser by entering <a href="http://localhost:3000/api/v1/parcels/f34c6658-818b-11e8-adc0-fa7ae01bbebc">http://localhost:3000/api/v1/parcels/f34c6658-818b-11e8-adc0-fa7ae01bbebc</a> and seeing our test data.</p>
<p>Now that the mailroom can access a single record, we need to be able to update that record. Let's write a test. Because sqlite doesn't return the inserted row as an object, it only returns the number of rows modified, we'll test that the number of modified rows is non-zero:</p>
<pre><code class="language-javascript">describe('PUT /api/v1/parcels/:barcode', function() {
  it('should update one parcel', function(done) {
    chai
      .request(server)
      .put('/api/v1/parcels/f34c6658-818b-11e8-adc0-fa7ae01bbebc')
      .send({
        shipment_weight: '1',
        shipment_length: '2',
        shipment_width: '3',
        shipment_height: '4',
        shipping_method: 'Expedited',
        shipment_status: 'Received',
      })
      .end(function(err, res) {
        res.should.have.status(200)
        res.should.be.json
        res.body.should.not.equal(0)
        done()
      })
  })
})
</code></pre>
<p>and it fails. Good. Now the route. This looks a little different than the previous route we made:</p>
<pre><code class="language-javascript">app.put('/api/v1/parcels/:barcode', async (req, res, next) => {
  try {
    const payload = {
      $barcode: req.params.barcode,
      $shipment_weight: req.body.shipment_weight,
      $shipment_length: req.body.shipment_length,
      $shipment_width: req.body.shipment_width,
      $shipment_height: req.body.shipment_height,
      $shipping_method: req.body.shipping_method,
      $shipment_status: req.body.shipment_status,
      $received_date: new Date().toISOString(),
    }
    const db = await dbPromise
    const parcels = await db.run(
      `UPDATE parcels SET
            shipment_weight=$shipment_weight,
            shipment_length=$shipment_length,
            shipment_width=$shipment_width,
            shipment_height=$shipment_height,
            shipping_method=$shipping_method,
            shipment_status=$shipment_status,
            received_date=$received_date
            WHERE barcode = $barcode`,
      payload
    )
    res.json(parcels.changes)
  } catch (err) {
    next(err)
  }
})
</code></pre>
<h3>DELETE</h3>
<p>Okay, now we have the ability to CREATE, READ, and UPDATE. Our envisioned use case doesn't have users deleting records, I think we would like to maintain old records for archival purposes. However, for completeness we'll add a simple DELETE route.</p>
<p>Let's first add another sample into our <code>001-init.sql</code> file with a static barcode. Add this ABOVE the previous insert, as we will see why in a second.</p>
<pre><code class="language-sql">INSERT INTO parcels
    (user_id, street_address, attn_name,
    attn_organization, city, state_or_province, country, postal_code, barcode)
VALUES
    ("1A", "I SHOULD BE DELETED", "Iron Man", "The Avengers", "New York City", "New York", "US", "12345", "f34c6658-818b-11e8-adc0-fa7ae01bbebb");
</code></pre>
<p>Now let's write a test in our <code>routes.spec.js</code> file for our deletion:</p>
<pre><code class="language-javascript">describe('DELETE /api/v1/parcels/:barcode', function() {
  it('should delete one parcel', function(done) {
    chai
      .request(server)
      .delete('/api/v1/parcels/f34c6658-818b-11e8-adc0-fa7ae01bbebb')
      .end(function(err, res) {
        res.should.have.status(200)
        res.should.be.json
      })
    chai
      .request(server)
      .get('/api/v1/parcels/')
      .end(function(err, res) {
        res.should.have.status(200)
        res.should.be.json
        res.body.should.be.a('array')
        res.body[0].should.have.property('barcode')
        res.body[0].barcode.should.equal('f34c6658-818b-11e8-adc0-fa7ae01bbebc')
      })
    done()
  })
})
</code></pre>
<p>Here we are sending a request to the server to delete the parcel with "I SHOULD BE DELETED" as an address (note the 'bb' at the end of the barcode instead of the 'bc').</p>
<p>The second request to the server is to get back the full list of parcels, and if the delete works as intended, the first parcel (in position [0]) should now be our parcel with barcode ending in 'bc'.</p>
<p>Run the test. It fails. Now write the route.</p>
<pre><code class="language-javascript">app.delete('/api/v1/parcels/:barcode', async (req, res, next) => {
  try {
    const db = await dbPromise
    const parcels = await db.run(
      'DELETE FROM parcels WHERE barcode = ?',
      req.params.barcode
    )
    res.json(parcels)
  } catch (err) {
    next(err)
  }
})
</code></pre>
<p>Run the tests...</p>
<pre><code>deans-Mac-Pro:mailroom dean$ mocha


  API Routes
    GET /api/v1/parcels
GET /api/v1/parcels 200 5.799 ms - 1037
      ✓ should return all parcels
    GET /api/v1/parcels/:barcode
GET /api/v1/parcels/f34c6658-818b-11e8-adc0-fa7ae01bbebc 200 1.022 ms - 517
      ✓ should return one parcel
    DELETE /api/v1/parcels/:barcode
      ✓ should delete one parcel
    PUT /api/v1/parcels/:barcode
DELETE /api/v1/parcels/f34c6658-818b-11e8-adc0-fa7ae01bbebb 200 2.549 ms - 79
GET /api/v1/parcels/ 200 2.028 ms - 519
PUT /api/v1/parcels/f34c6658-818b-11e8-adc0-fa7ae01bbebc 200 1.289 ms - 1
      ✓ should update one parcel
    POST /api/v1/parcels
POST /api/v1/parcels 200 1.686 ms - 36
      ✓ should create one parcel


  5 passing (79ms)
</code></pre>
<p>And it works! Now we have a fully functional basic CRUD API.</p>
<h2>Front End</h2>
<p>I would like to have the front end built with React to take advantage of component architecture, however to quickly test that everything works we can build a simple HTML page.</p>
<p>We should already have a page called <code>index.html</code> in our ./public folder. Let's open that up and add a basic form for our users.</p>
<h3>User view</h3>
<p>Here's what <code>index.html</code> should look like:</p>
<pre><code class="language-html">&#x3C;html>

&#x3C;head>
  &#x3C;title>Express&#x3C;/title>
  &#x3C;link rel="stylesheet" href="/stylesheets/style.css">
&#x3C;/head>

&#x3C;body>
  &#x3C;h1>Express&#x3C;/h1>
  &#x3C;p>Welcome to Express&#x3C;/p>

  &#x3C;form action="/api/v1/parcels" method="post">
    User ID:
    &#x3C;input type="text" name="user_id">
    &#x3C;input type="submit" value="Submit">
  &#x3C;/form>

&#x3C;/body>

&#x3C;/html>
</code></pre>
<p>Now open <a href="http://localhost:3000">http://localhost:3000</a> and try it out!</p>
<p><img src="/screenshots/001.png" alt="screenshot of index"></p>
<p>So what's happening here is when you type your User ID in the text field and hit the submit button we use the POST route we made earlier to create a new record in our database.</p>
<p><img src="/screenshots/002.png" alt="screenshot of barcode result"></p>
<p>As we can see by the random string of numbers and letters we receive back, we are successfully viewing the barcode of our created entry.</p>
<p>At this point we will add additional fields from our database.</p>
<p>We will also add any remaining fields to the routes.</p>
<p>Now our webpage looks like this! (I also just learned how to take nicer screenshots of the selected window)</p>
<p><img src="/screenshots/004.png" alt="screenshot of user view"></p>
<p>And our fields are nicely populating in the database.</p>
<p><img src="/screenshots/005.png" alt="screenshot of JSON from database"></p>
<h3>Mailroom View</h3>
<p>We want our mailroom to be able to nput a barcode, view a record, add additional information, and save it to the database.</p>
<p>Lets create a new folder and HTML file <code>$ touch mailroom/index.html</code> and open it up, add the following:</p>
<pre><code class="language-html">&#x3C;html>

&#x3C;head>
    &#x3C;title>Express&#x3C;/title>
    &#x3C;link rel="stylesheet" href="/stylesheets/style.css">
&#x3C;/head>

&#x3C;body>
    &#x3C;h1>Mailroom View&#x3C;/h1>
    &#x3C;p>Please enter a barcode to retrieve a record&#x3C;/p>
    &#x3C;form action="/api/v1/parcels" method="get">
        Barcode:
        &#x3C;input type="text" name="barcode">
        &#x3C;input type="submit" value="Submit">
    &#x3C;/form>
&#x3C;/body>

&#x3C;/html>
</code></pre>
<p>Now navigate to <a href="http://localhost:3000/mailroom/">http://localhost:3000/mailroom/</a> and see that it appears!</p>
<p><img src="/screenshots/006.png" alt="screenshot of mailroom view"></p>
<p>If we enter a barcode from our database and hit submit...</p>
<p>Uh oh.
<img src="/screenshots/007.png" alt="screenshot of mailroom view"></p>
<p>We get back an array of all our parcels. Not what we're looking for. If we look in the address bar we can see why this is happening: the barcode is being sent to the /api/v1/parcels route as a query parameter instead of using the /api/v1/:barcode route we defined earlier.</p>
<p>Now we can decide to use the barcode as a query parameter and refactor our routes, or we can see if the form can submit to our /api/v1/:barcode route as a path variable. I'm sure one answer is better than the other for this scenario, but as our HTML form is presenting us with the query option by default we will try that first.</p>
<p>We will change our route to the following which will show us a specific parcel when a barcode is supplied as a query parameter.</p>
<pre><code class="language-javascript">app.get('/api/v1/parcels', async (req, res, next) => {
  try {
    const query = { $barcode: req.query.barcode }
    const db = await dbPromise
    const parcels = await db.all(
      'SELECT * FROM parcels WHERE ($barcode IS NULL OR barcode = $barcode)',
      query
    )
    res.send(parcels)
  } catch (err) {
    next(err)
  }
})
</code></pre>
<h3>Adding React</h3>
<p>We are going to use React for our frontend framework to handle dynamic content changes, and because we're looking to have it rendered server-side we will also use nextjs.</p>
<p>Let's make a client directory to handle our client-side code <code>$ mkdir client &#x26;&#x26; cd client</code> then initialize a new package.json with <code>$ npm init -y</code> and install next with <code>$ npm install -s react react-dom next</code></p>
<p>If we add the following to our package.json</p>
<pre><code class="language-javascript">{
  "scripts": {
    "dev": "next",
    "build": "next build",
    "start": "next start"
  }
}
</code></pre>
<p>and create a pages directory with an index.js file</p>
<p><code>$ mkdir pages &#x26;&#x26; touch pages/index.js</code></p>
<p>now add a simple export</p>
<pre><code class="language-javascript">export default () => {
  return &#x3C;div>Hello World&#x3C;/div>
}
</code></pre>
<p>run <code>$ npm run dev</code> and open <a href="http://localhost:3030">http://localhost:3030</a> (in my case)to see our message!</p>
<p>Let's rewrite our two pages as components.</p>
<p>Starting with a <code>users.js</code> in our pages folder</p>
<pre><code class="language-javascript">import React, { Component } from 'react'

export default class UserPage extends Component {
  render() {
    return (
      &#x3C;div>
        &#x3C;h1>User View&#x3C;/h1>
        &#x3C;p>Please fill out the following form to generate your shipping code&#x3C;/p>

        &#x3C;form action="/api/v1/parcels" method="post">
          &#x3C;fieldset>
            &#x3C;legend>User Information&#x3C;/legend>
            User ID:
            &#x3C;input type="text" name="user_id" />
            &#x3C;br /> File Number:
            &#x3C;input type="text" name="file_id" />
          &#x3C;/fieldset>
          &#x3C;br />
          &#x3C;fieldset>
            &#x3C;legend>Package Information&#x3C;/legend>
            &#x3C;input type="radio" name="shipment_type" value="mail" /> Mail
            &#x3C;input type="radio" name="shipment_type" value="parcel" /> Parcel
            &#x3C;br /> Destination:
            &#x3C;select name="shipment_locale">
              &#x3C;option value="local">Within the Lower Mainland&#x3C;/option>
              &#x3C;option value="national">Within Canada&#x3C;/option>
              &#x3C;option value="international">International&#x3C;/option>
            &#x3C;/select>
            &#x3C;br /> Shipping Speed:
            &#x3C;select name="shipment_speed">
              &#x3C;option value="one">One&#x3C;/option>
              &#x3C;option value="two">Two&#x3C;/option>
              &#x3C;option value="three">Three&#x3C;/option>
            &#x3C;/select>
          &#x3C;/fieldset>
          &#x3C;br />
          &#x3C;fieldset>
            &#x3C;legend>Recipient Information&#x3C;/legend>
            Recipient Name:
            &#x3C;input type="text" name="attn_name" />
            &#x3C;br /> Phone Number:
            &#x3C;input type="tel" name="attn_phone" />
            &#x3C;br /> Organization:
            &#x3C;input type="text" name="attn_organization" />
          &#x3C;/fieldset>
          &#x3C;br />
          &#x3C;fieldset>
            &#x3C;legend>Shipping Address&#x3C;/legend>
            Address:
            &#x3C;input type="text" name="street_address" />
            &#x3C;br /> City:
            &#x3C;input type="text" name="city" />
            &#x3C;br /> Province/State:
            &#x3C;input type="text" name="state_or_province" />
            &#x3C;br /> Country:
            &#x3C;input type="text" name="country" />
            &#x3C;br /> Postal Code:
            &#x3C;input type="text" name="postal_code" />
          &#x3C;/fieldset>
          &#x3C;br />
          &#x3C;input type="submit" value="Submit" />
        &#x3C;/form>
      &#x3C;/div>
    )
  }
}
</code></pre>
<p>Which will now be available at <a href="http://localhost:3030/user">http://localhost:3030/user</a></p>
<p>And make a new file for our mailroom at /pages/mailroom.js</p>
<pre><code class="language-javascript">const MailroomPage = () => {
  return (
    &#x3C;div>
      &#x3C;h1>Mailroom View&#x3C;/h1>
      &#x3C;p>Please enter a barcode to retrieve a record&#x3C;/p>
      &#x3C;form action="/api/v1/parcels" method="get">
        Barcode:
        &#x3C;input type="text" name="barcode" />
        &#x3C;input type="submit" value="Submit" />
      &#x3C;/form>
    &#x3C;/div>
  )
}

export default MailroomPage
</code></pre>
<p>Which will now be available at <a href="http://localhost:3030/mailroom">http://localhost:3030/mailroom</a></p>
<h3>Showing the QR code on submission</h3>
<p>Next steps are to handle the form using React's "controlled components" and display the resulting barcode as a QR code on the same page.</p>
<p>We'll start by adding a constructor and input handler to our userpage component</p>
<pre><code class="language-javascript">export default class UserPage extends Component {
  constructor(props) {
    super(props);
    this.state = {
      user_id: '',
      file_id: '',
      shipment_type: '',
      shipment_locale: '',
      shipment_speed: '',
      attn_name: '',
      attn_phone: '',
      attn_organization: '',
      street_address: '',
      city: '',
      state_or_province: '',
      country: '',
      postal_code: ''
    };

    this.handleChange = this.handleInputChange.bind(this);
  }

  handleInputChange(event) {
    const target = event.target;
    const value = target.type === 'checkbox' ? target.checked : target.value;
    const name = target.name;
    this.setState({ [name]: value });
  }
  ...
</code></pre>
<p>and on each <code>&#x3C;input></code> we will add <code>value={this.state.###} onChange={this.handleChange}</code> where ### is the name of that input, for example:</p>
<pre><code class="language-javascript">&#x3C;input
  type="text"
  name="user_id"
  value={this.state.user_id}
  onChange={this.handleChange}
/>
</code></pre>
<p>our Radio buttons will look slightly different:</p>
<pre><code class="language-javascript">&#x3C;input
  type="radio"
  name="shipment_type"
  value="mail"
  checked={this.state.shipment_type === 'mail'}
  onChange={this.handleChange}
/>
</code></pre>
<p>as will our Select options:</p>
<pre><code class="language-javascript">&#x3C;select
  name="shipment_locale"
  value={this.state.shipment_locale}
  onChange={this.handleChange}
>
  &#x3C;option value="local">Within the Lower Mainland&#x3C;/option>
  &#x3C;option value="national">Within Canada&#x3C;/option>
  &#x3C;option value="international">International&#x3C;/option>
&#x3C;/select>
</code></pre>
<p>Now if we were to check in React Developer Tools (a Chrome addon) we should see all our state values populating correctly</p>
<p><img src="/screenshots/009.png" alt="screenshot of React Developer Tools"></p>
<p>Now lets change the form behaviour:</p>
<pre><code class="language-javascript">&#x3C;form action="/api/v1/parcels" method="post">
</code></pre>
<p>changes to</p>
<pre><code class="language-javascript">&#x3C;form onSubmit={this.handleSubmit}>
</code></pre>
<p>and we'll write a function to handle the POST request in Javascript.</p>
<p>add to our constructor:
<code>this.handleSubmit = this.handleSubmit.bind(this);</code>
and create the function:</p>
<pre><code class="language-javascript">  handleSubmit(event) {
    alert('Test' + JSON.stringify(this.state));
    event.preventDefault();
  }
</code></pre>
<p>And now when we hit the Submit button we should see our data appear in an alert box in the browser window.</p>
<h3>CORS</h3>
<p>Let's modify the <code>handleSubmit</code> function to post JSON to our API route.</p>
<pre><code class="language-javascript">  handleSubmit(event) {
    fetch(`http://localhost:3000/api/v1/parcels`, {
      method: 'POST',
      mode: 'cors',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(this.state)
    })
      .then(response => response.json())
      .then(data => {
        console.log(data.message);
        this.setState({ barcode: data.barcode });
      })
      .catch(error => console.error(error));
    event.preventDefault();
</code></pre>
<p>Now we run into a CORS (Cross Origin Resource Sharing) issue. This is because, in my case, the API server is running on localhost:3000 and the nextjs server is running on localhost:3030</p>
<p>To solve this: in our root project directory (ie. not in the client folder) run <code>$ npm install -s cors</code>. Open app.js and add</p>
<pre><code class="language-javascript">const cors = require('cors')

app.use(cors())
</code></pre>
<p>now restart the server <code>$ npm start</code> and try the request from the client again.</p>
<p>We should see a "Success!" message in our console, and our barcode in our component's state!</p>
<p><img src="/screenshots/010.png" alt="screenshot of React Developer Tools - success"></p>
<h3>The QR Code</h3>
<p>Next up: creating a component that will display our QR code.</p>
<p>Let start with a components folder in our client directory <code>$ mkdir client/components</code> and create a file called <code>label.js</code></p>
<p>In <code>label.js</code> we'll create a simple functional component that accepts props.</p>
<pre><code class="language-javascript">import React from 'react'

export default props => {
  return &#x3C;div>{props.barcode}&#x3C;/div>
}
</code></pre>
<p>In <code>user.js</code> we'll add to the top:</p>
<pre><code class="language-javascript">import Label from '../components/label'
</code></pre>
<p>and under the closing form tag add a <code>&#x3C;Label barcode={this.state.barcode} /></code> tag.</p>
<p>Now when we submit the form, our barcode string appears!</p>
<p>In our client directory, run <code>$ npm install -s bwip-js</code> which is the library that will allow us to generate QR codes.</p>
<p>In <code>label.js</code> add our import statement and modify the functional component to a class component:</p>
<pre><code class="language-javascript">import React, { Component } from 'react'
import bwipjs from 'bwip-js'

export default class Label extends Component {
  constructor(props) {
    super(props)
  }

  componentDidUpdate() {
    bwipjs(
      'target-canvas',
      {
        bcid: 'qrcode',
        text: this.props.barcode,
      },
      (err, cvs) => {
        if (err) {
          console.error(err)
        }
      }
    )
  }

  render() {
    return (
      &#x3C;div>
        &#x3C;canvas id="target-canvas" />
      &#x3C;/div>
    )
  }
}
</code></pre>
<p>Now fill out the form and click submit. Voila! A QR code appears.</p>
<h3>The Mailroom View</h3>
<p>To make the next part easier, I made a component that lists all existing records in the database.</p>
<pre><code class="language-javascript">import React, { Component } from 'react'

export default class LabelList extends Component {
  constructor(props) {
    super(props)

    this.state = { data: [] }
  }

  componentDidMount = () => {
    fetch(`http://localhost:3000/api/v1/parcels`)
      .then(response => response.json())
      .then(data => this.setState({ data: data }))
      .catch(err => console.error(err))
  }

  render() {
    return (
      &#x3C;div>
        &#x3C;h3>All Records&#x3C;/h3>
        {this.state.data.map(label => {
          return &#x3C;div key={label.id}>{label.barcode}&#x3C;/div>
        })}
      &#x3C;/div>
    )
  }
}
</code></pre>
<p>then <code>import LabelList from '../components/labelList';</code> and add <code>&#x3C;LabelList /></code> under the form in the mailroom view.</p>
<p><img src="/screenshots/011.png" alt="screenshot of mailroom barcode list"></p>
<p>Now it will be easy to grab a barcode to test.</p>
<p>Lets create a component to render our retrieved record from the database:</p>
<pre><code class="language-javascript">// Record.js
import React, { Component } from 'react'

export default class Record extends Component {
  constructor(props) {
    super(props)

    this.state = {}
  }

  render() {
    return &#x3C;div>{this.props.data.barcode}&#x3C;/div>
  }
}
</code></pre>
<p>And let's modify the mailroom with some of the same code we used in the user view, handleSubmit and handleChange</p>
<pre><code class="language-javascript">// mailroom.js
import React, { Component } from 'react'
import LabelList from '../components/labelList'
import Record from '../components/Record'

export class MailroomPage extends Component {
  constructor(props) {
    super(props)
    this.state = { barcode: '', data: {} }

    this.handleChange = this.handleChange.bind(this)
    this.handleSubmit = this.handleSubmit.bind(this)
  }

  handleSubmit(event) {
    fetch(`http://localhost:3000/api/v1/parcels?barcode=${this.state.barcode}`)
      .then(response => response.json())
      .then(data => {
        this.setState({ data: data[0] })
      })
      .catch(error => console.error(error))
    event.preventDefault()
  }

  handleChange(event) {
    const target = event.target
    const value = target.type === 'checkbox' ? target.checked : target.value
    const name = target.name
    this.setState({ [name]: value })
  }

  render() {
    return (
      &#x3C;div>
        &#x3C;h1>Mailroom View&#x3C;/h1>
        &#x3C;p>Please enter a barcode to retrieve a record&#x3C;/p>
        &#x3C;form onSubmit={this.handleSubmit}>
          Barcode:
          &#x3C;input
            type="text"
            name="barcode"
            value={this.state.attn_name}
            onChange={this.handleChange}
          />
          &#x3C;input type="submit" value="Submit" />
        &#x3C;/form>
        &#x3C;Record data={this.state.data} />
        &#x3C;LabelList />
      &#x3C;/div>
    )
  }
}

export default MailroomPage
</code></pre>
<p>Now when we submit a barcode, we should see the name of our recipient.</p>
<h3>Fleshing things out a bit.</h3>
<p>Here are some easy steps I completed without documenting:</p>
<ul>
<li>Header component with navigation links to make it easy to swap between views.</li>
<li>More information on record retrieval in the Record component.</li>
<li>More fields in the Label component to give the user feedback on their submission</li>
</ul>
<h2>Next Steps</h2>
<p>And the next steps for the project:</p>
<ol>
<li>Add the ability for the Mailroom to edit retrieved information and update the database.</li>
<li>Autofocus the Barcode entry field to make it easier to use a QR Code scanner</li>
<li>Format the Label the user creates to make it nicely printable.</li>
<li>Add authentication so only authorized users can access the Mailroom.</li>
</ol></div></div></div></div></div></div><script id="webpack-manifest">/*<![CDATA[*/window.webpackManifest={"231608221292675":"app-7f8c8c2352d9d219a48d.js","122212659448958":"component---src-templates-blog-template-js-580e315ea23c55a6f93d.js","162898551421021":"component---src-pages-404-js-4503918ea3a16cfcdb75.js","35783957827783":"component---src-pages-index-js-7cc5a0d5bec8d9b7aae6.js","60335399758886":"path----f56a5fe1fa6bfafbe0e9.js","273950069227526":"path---about-ac30a6161478ef98a8fe.js","27027048473407":"path---projects-mailroom-0703996f543ef3573f7c.js","169827572607570":"path---projects-ferrytracker-15d8bd086e76b107d0eb.js","163496051235567":"path---projects-brincao-f4ef6fc2bf9785d6e9e8.js","6709832987247":"path---projects-flextogcal-0376b87d7ba3725aedca.js","250301090669686":"path---projects-bc-votes-a1e3ed7b58bcb562e547.js","199803406507071":"path---projects-the-last-skytrain-cd1c15745f3935fe3259.js","254022195166212":"path---404-a0e39f21c11f6a62c5ab.js","142629428675168":"path---index-3fbf72abf7904ee5157e.js","178698757827068":"path---404-html-a0e39f21c11f6a62c5ab.js","114276838955818":"component---src-layouts-index-js-c7b949255d617ff6f539.js"}/*]]>*/</script><script>/*<![CDATA[*/!function(e,t,r){function n(){for(;d[0]&&"loaded"==d[0][f];)c=d.shift(),c[o]=!i.parentNode.insertBefore(c,i)}for(var s,a,c,d=[],i=e.scripts[0],o="onreadystatechange",f="readyState";s=r.shift();)a=e.createElement(t),"async"in i?(a.async=!1,e.head.appendChild(a)):i[f]?(d.push(a),a[o]=n):e.write("<"+t+' src="'+s+'" defer></'+t+">"),a.src=s}(document,"script",["/commons-afb5782224ac01f1fa03.js","/app-7f8c8c2352d9d219a48d.js","/path---projects-mailroom-0703996f543ef3573f7c.js","/component---src-templates-blog-template-js-580e315ea23c55a6f93d.js","/component---src-layouts-index-js-c7b949255d617ff6f539.js"])/*]]>*/</script></body></html>